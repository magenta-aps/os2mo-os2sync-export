# SPDX-FileCopyrightText: Magenta ApS
#
# SPDX-License-Identifier: MPL-2.0
import asyncio
from uuid import UUID

import click
import httpx
from authlib.integrations.httpx_client import AsyncOAuth2Client  # type: ignore
from tqdm.asyncio import tqdm

from os2sync_export.autogenerated_graphql_client import GraphQLClient
from os2sync_export.autogenerated_graphql_client.client import gql
from os2sync_export.config import Settings

"""
Script for testing equivalence between old and new version of the integration.
Works by finding uuids of every org_unit and person in MO and triggering a dry-run of the integration using the "new" flag.
We can then assert that the output is the same for new=True and new=False.

This only works as long as the configuration is set to new=False.

> docker compose exec -it os2sync_export python -m os2sync_export.equivalence_test
"""

org_unit_query = """
    query OrgUnits($limit: int, $cursor: Cursor = null) {
      org_units(cursor: $cursor, limit: $limit) {
        page_info {
          next_cursor
        }
        objects {
          uuid
        }
      }
    }
        """

person_query = """
    query Persons($limit: int, $cursor: Cursor = null) {
      employees(cursor: $cursor, limit: $limit) {
        page_info {
          next_cursor
        }
        objects {
          uuid
        }
      }
    }
        """


async def read_all_units_and_persons(graphql_client) -> tuple[set[UUID], set[UUID]]:
    units = set()
    variables = {"limit": 1000}
    while True:
        res = (await graphql_client.execute(gql(org_unit_query), variables)).json()[
            "data"
        ]["org_units"]
        for unit in res["objects"]:
            units.add(UUID(unit["uuid"]))
        if not res["page_info"]["next_cursor"]:
            break
        variables["cursor"] = res["page_info"]["next_cursor"]

    persons = set()
    variables = {"limit": 1000}
    while True:
        res = (await graphql_client.execute(gql(person_query), variables)).json()[
            "data"
        ]["employees"]
        for person in res["objects"]:
            persons.add(UUID(person["uuid"]))
        if not res["page_info"]["next_cursor"]:
            break
        variables["cursor"] = res["page_info"]["next_cursor"]
    return units, persons


@click.command()
def test_equivalence():
    # Setup graphql_client
    settings = Settings()  # type: ignore
    mo_client = AsyncOAuth2Client(
        base_url=settings.fastramqpi.mo_url,
        client_id=settings.fastramqpi.client_id,
        client_secret=settings.fastramqpi.client_secret.get_secret_value(),
        grant_type="client_credentials",
        token_endpoint=f"{settings.fastramqpi.auth_server}/realms/{settings.fastramqpi.auth_realm}/protocol/openid-connect/token",
        token={"expires_at": -1, "access_token": ""},
        timeout=settings.fastramqpi.graphql_timeout,
    )
    gql_client = GraphQLClient(
        url=f"{settings.fastramqpi.mo_url}/graphql/v25",
        http_client=mo_client,
    )
    click.echo("Reading units and persons from MO")
    units, persons = asyncio.run(read_all_units_and_persons(gql_client))
    click.echo(f"Found {len(units)} units and {len(persons)} persons.")

    for person in tqdm(persons, desc="persons"):
        old = httpx.post(
            f"http://localhost:8000/trigger/user/{person}?dry_run=true", timeout=None
        )
        new = httpx.post(
            f"http://localhost:8000/trigger/user/{person}?dry_run=true&new=true",
            timeout=None,
        )
        if not old.json() == new.json():
            click.echo(f"User mismatch: {old.json()=} != {new.json()=}")

    for unit in tqdm(units, desc="units"):
        old = httpx.post(
            f"http://localhost:8000/trigger/org_unit/{unit}?dry_run=true", timeout=None
        )
        new = httpx.post(
            f"http://localhost:8000/trigger/org_unit/{unit}?dry_run=true&new=true",
            timeout=None,
        )
        if old.json() != new.json():
            click.echo(f"Orgunit mismatch: {old.json()=} != {new.json()=}")


if __name__ == "__main__":
    test_equivalence()
